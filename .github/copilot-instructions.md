# OrcBot AI Coding Instructions

- **Architecture**: The CLI entrypoint wires everything in [src/cli/index.ts](src/cli/index.ts); the core agent lives in [src/core/Agent.ts](src/core/Agent.ts) and orchestrates memory, LLM access, skills, channels, web browser, and scheduling.
- **Data paths**: Config defaults resolve to the user home `.orcbot` folder (see [src/config/ConfigManager.ts](src/config/ConfigManager.ts) & [src/cli/setup.ts](src/cli/setup.ts)). Memory, profiles, journal, learning, and action queue are file-backed; avoid breaking absolute paths and ensure new files land under that data dir.
- **LLM routing**: [src/core/MultiLLM.ts](src/core/MultiLLM.ts) chooses provider by model name (gemini → Google, otherwise OpenAI) and auto-falls back to the other provider on failure; prefer passing `systemMessage` into `call` and let it decide provider.
- **Planning + execution**: [src/core/SimulationEngine.ts](src/core/SimulationEngine.ts) produces the pre-plan text; [src/core/DecisionEngine.ts](src/core/DecisionEngine.ts) consumes memories, journal/learning snippets, channel metadata, and skill prompts to drive the JSON response contract from [src/core/ParserLayer.ts](src/core/ParserLayer.ts). Keep responses JSON-wrapped and support multi-tool `tools` arrays.
- **Scheduler/events**: Background ticks come from [src/core/Scheduler.ts](src/core/Scheduler.ts) emitting `scheduler:tick` on the shared [event bus](src/core/EventBus.ts); new background jobs should subscribe instead of polling.
- **Skills**: Core skills are registered inside [src/core/Agent.ts](src/core/Agent.ts) and dynamically loaded plugins through [src/core/SkillsManager.ts](src/core/SkillsManager.ts). Plugins must export an object `{ name, description, usage, handler }`; handler receives `args` and a context with `browser`, `config`, `agent`, `logger`. Use `context.config.get(...)` for secrets and `context.logger` for logging.
- **Plugin loading/repair**: SkillsManager loads `.ts/.js` from the plugins dir using ts-node; broken plugins trigger a high-priority `self_repair_skill` task. Keep plugin code CommonJS-friendly for `require` and add `// @source:` header when generating from specs (see [src/cli/builder.ts](src/cli/builder.ts)).
- **Memory**: [src/memory/MemoryManager.ts](src/memory/MemoryManager.ts) persists memories in JSON and consolidates short-term items into episodic summaries after 30 entries using the LLM. Contact profiles are stored per-JID in `~/.orcbot/profiles`; reuse this when adding contact-level features.
- **Action queue**: [src/memory/ActionQueue.ts](src/memory/ActionQueue.ts) is the durable queue sorted by priority; statuses are persisted to the backing JSON. Use the event bus (`action:push`, `action:queued`) rather than in-memory arrays.
- **Channels**: Telegram (Telegraf) lives in [src/channels/TelegramChannel.ts](src/channels/TelegramChannel.ts); WhatsApp (Baileys) in [src/channels/WhatsAppChannel.ts](src/channels/WhatsAppChannel.ts). Both write inbound messages to memory and can auto-push tasks when auto-reply flags are enabled. Media downloads go to `~/.orcbot/downloads`; Telegram chunks long sends; WhatsApp ensures `@s.whatsapp.net` suffix.
- **Browser tooling**: [src/tools/WebBrowser.ts](src/tools/WebBrowser.ts) wraps Playwright with semantic snapshots (`data-orcbot-ref` selectors) and supports Serper-first search, Google/Bing/DDG fallbacks, and 2Captcha solving. When adding actions, honor ref-based selectors and keep timeouts/resilience behavior intact.
- **Config knobs**: Feature toggles and API keys (OpenAI, Google, Serper, captcha, channel tokens) flow through ConfigManager. CLI `orcbot config set/get` mutates config; setup wizard writes `~/.orcbot/orcbot.config.yaml` and `.env` (see [src/cli/setup.ts](src/cli/setup.ts)).
- **CLI workflows**: Primary commands: `npm run dev` (ts-node), `npm run build` (tsc to dist), `npm start` (runs built CLI). User-facing commands: `orcbot run` (loop), `orcbot ui` (TUI menus), `orcbot push "task" -p 10`, `orcbot reset`, `orcbot builder <url>`.
- **Frontend**: The marketing site under [apps/www](apps/www) is a Vite React app; run `npm install && npm run dev` inside that folder. Keep UI minimal and static; it only advertises install flow.
- **Logging & errors**: Use the shared Winston logger ([src/utils/logger.ts](src/utils/logger.ts)); retry/fallback utilities are in [src/utils/ErrorHandler.ts](src/utils/ErrorHandler.ts) and already used by LLM calls.
- **Security/keys**: Never hardcode API keys; always pull from `ConfigManager.get`. Respect the home-directory data layout so user data stays local.
- **Testing coverage**: There is no test suite today; exercise critical paths manually via `npm run dev` + `orcbot ui` and channel simulators.
- **Style**: Keep code TypeScript-first, file-backed persistence, and event-driven over in-memory state. Prefer minimal external deps beyond what is already declared.

If anything here feels incomplete or you need deeper detail on a subsystem, let me know and I’ll refine it.